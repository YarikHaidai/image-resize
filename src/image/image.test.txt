import * as AWS from 'aws-sdk';
import * as sharp from 'sharp';
import {Readable} from 'stream';

const defaultDimension = 2560;
type dimension = number | undefined;
enum ContentType {
    Png = 'image/png',
    Jpg = 'image/jpg'
}

import {APIGatewayEvent, APIGatewayProxyResult, Handler} from 'aws-lambda';
import {SharpInstance} from 'sharp';

export const resize: Handler = async (event: APIGatewayEvent) => {
    const params = event.queryStringParameters || {};
    const [, , bucket, username, subkey] = event.path
        .split('/')
        .map(decodeURIComponent);
    const key = username + (subkey ? /${subkey} : '');
    const width = parseInt(params.width, 10) || defaultDimension;
    const height = parseInt(params.height, 10) || defaultDimension;

    if (!areDimensionsValid(width, height)) {
        return buildErrorResponse(422);
    }

    try {
        const [stream, contentType] = await createReadStream(key, bucket);
        const [pipeline, outputContentType] = createPipeline(
            width,
            height,
            contentType
        );
        const image = await resizeImage(stream, pipeline);

        return buildResponse(image, outputContentType);
    } catch (error) {
        console.error(`Error while fetching ${key} from ${bucket}`, error);

        if (error.name === 'NoSuchKey') {
            return buildErrorResponse(404);
        }

        return buildErrorResponse(500);
    }
};

/**
 * Make request to the S3 bucket and create readable stream
 * @param key - key of item in the bucket
 * @param bucket - name of the bucket
 */
async function createReadStream(
    key: string,
    bucket: string
): Promise<[Readable, ContentType]> {
    const s3Client = new AWS.S3();
    const params = {
        Key: key,
        Bucket: bucket
    };

    return new Promise<[Readable, ContentType]>((resolve, reject) => {
        s3Client
            .getObject(params)
            .on('httpHeaders', (statusCode, headers, response) => {
                if (statusCode < 300) {
                    resolve([
                        response.httpResponse.createUnbufferedStream() as Readable,
                        headers['content-type'] as ContentType
                    ]);
                } else {
                    reject(
                        new Error(`GetObject response with status code ${statusCode}`)
                    );
                }
            })
            .on('error', error => {
                reject(error);
            })
            .send();
    });
}

/**
 * Build successful response
 * @param {Buffer} image - processed image
 * @param {ContentType} contentType
 * @returns {APIGatewayProxyResult}
 */
function buildResponse(
    image: Buffer,
    contentType: ContentType
): APIGatewayProxyResult {
    return {
        statusCode: 200,
        headers: {
            'Content-Type': contentType
        },
        body: image.toString('base64'),
        isBase64Encoded: true
    };
}

function buildErrorResponse(code: number): APIGatewayProxyResult {
    return {
        statusCode: code,
        body: ''
    };
}

/**
 * We support fixed number of output resolutions. Validate given dimensions are valid.
 * @param width - width of the output image
 * @param height - height of the output image
 */
function areDimensionsValid(width: dimension, height: dimension): boolean {
    const allowedDimensions = new Map<dimension, dimension>([
        // width, height
        [200, 200],
        [750, defaultDimension],
        [1500, 1500],
        [defaultDimension, defaultDimension] // full size
    ]);

    return (
        allowedDimensions.has(width) && allowedDimensions.get(width) === height
    );
}

/**
 * Configure sharp image processing and output image options depending on original image content type
 * @param width - width of the output image
 * @param height - height of the output image
 * @param contentType - content type of the incoming image
 */
function createPipeline(
    width: dimension,
    height: dimension,
    contentType: ContentType
): [SharpInstance, ContentType] {
    const pipeline = sharp()
        .resize(width, height)
        .max()
        .withoutEnlargement();

    if (contentType === ContentType.Png) {
        return [
            pipeline.png({
                progressive: true,
                compressionLevel: 8
            }),
            ContentType.Png
        ];
    }

    return [
        pipeline.jpeg({
            quality: 90,
            progressive: true
        }),
        ContentType.Jpg
    ];
}

/**
 * Pipe incoming image stream through Sharp pipeline and buffer the output
 * @param stream - incoming image
 * @param pipeline - Sharp pipeline
 * @returns {Promise<Buffer>}
 */
function resizeImage(stream: Readable, pipeline: SharpInstance): Promise<Buffer> {
    return new Promise<Buffer>((resolve, reject) => {
        stream
            .once('readable', async () => {
                const image = stream
                    .pipe(pipeline)
                    .on('error', reject)
                    .toBuffer();

                resolve(image);
            })
            .on('error', reject);
    });
}